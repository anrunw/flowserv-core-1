# This file is part of the Reproducible and Reusable Data Analysis Workflow
# Server (flowServ).
#
# Copyright (C) 2019-2020 NYU.
#
# flowServ is free software; you can redistribute it and/or modify it under the
# terms of the MIT License; see LICENSE file for more details.

"""Unit test for downloading results of a post-processing workflow."""

import os
import time

from flowserv.controller.serial.engine import SerialWorkflowEngine
from flowserv.service.run.argument import FILE
from flowserv.tests.files import FakeStream
from flowserv.tests.service import create_group, create_user

import flowserv.tests.serialize as serialize
import flowserv.util as util


DIR = '../../.files/benchmark'
DIR = os.path.join(os.path.dirname(os.path.realpath(__file__)), DIR)
TEMPLATE_DIR = os.path.join(DIR, 'helloworld')
SPEC_FILE = os.path.join(DIR, 'postproc/benchmark.yaml')


def create_run(api, workflow_id):
    user_id = create_user(api)
    group_id = create_group(api, workflow_id=workflow_id, users=[user_id])
    file_id = api.uploads().upload_file(
        group_id=group_id,
        file=FakeStream(data=['Alice', 'Bob'], format='txt/plain').save(),
        name='n.txt',
        user_id=user_id
    )['id']
    api.runs().start_run(
        group_id=group_id,
        arguments=[{'id': 'names', 'value': FILE(file_id)}],
        user_id=user_id
    )


def test_workflow_postproc_results(service):
    """Test downloading results from a post-processing workflow."""
    # -- Setup ----------------------------------------------------------------
    #
    # Create instance of the 'Hello World' workflow.
    # run each.
    with service() as api:
        workflow_id = api.workflows().create_workflow(
            name='W1',
            source=TEMPLATE_DIR,
            specfile=SPEC_FILE
        )['id']
    # -- Create three groups and a successful run for each. Then read the
    # result files ------------------------------------------------------------
    for run_count in range(3):
        engine = SerialWorkflowEngine(is_async=False)
        with service(engine=engine) as api:
            engine.fs = api.fs
            create_run(api, workflow_id)
            # Get the workflow handle. At this point, the post-processing run
            # may not have started. Wait until it starts. Add 'watch-dog'
            # counter to avoid endless-loop in case of an error
            w = api.workflows().get_workflow(workflow_id)
            counter = 0
            while 'postproc' not in w:
                # The post-processing workflow should start within 10 seconds.
                counter += 1
                if counter == 10:
                    break
                time.sleep(1)
                w = api.workflows().get_workflow(workflow_id)
            assert counter < 10
            r = api.workflows().get_ranking(workflow_id)
            serialize.validate_ranking(r)
            api.workflows().get_result_archive(workflow_id=workflow_id)
            # Get the file handle for the comparison result file. This assumes
            # that there is only one resource generated by the post-processing
            # workflow.
            fh, filename = api.workflows().get_result_file(
                workflow_id=workflow_id,
                file_id=w['postproc']['files'][0]['id']
            )
            results = util.read_object(filename)
            assert len(results) == run_count + 1
